<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Loyc.Ecs</name>
    </assembly>
    <members>
        <member name="T:Loyc.Ecs.Parser.EcsLexer">
            <summary>Lexer for EC# source code (see <see cref="T:Loyc.Syntax.Lexing.ILexer`1"/>).</summary>
            <seealso cref="T:Loyc.Syntax.Lexing.TokensToTree"/>
        </member>
        <member name="T:Loyc.Ecs.Parser.EcsParser">
            <summary>Parses Enhanced C# code into a sequence of Loyc trees 
            (<see cref="T:Loyc.Syntax.LNode"/>), one per top-level statement.</summary>
            <remarks>
            You can use <see cref="F:Loyc.Ecs.EcsLanguageService.Value"/> with extension method
            <see cref="M:Loyc.Syntax.ParsingService.Parse(Loyc.Syntax.IParsingService,Loyc.UString,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,System.Boolean)"/>
            to easily parse a text string (holding zero or more EC# statements) into a 
            Loyc tree. One does not normally use this class directly.
            </remarks>
        </member>
        <member name="F:Loyc.Ecs.Parser.EcsParser.StartExpr">
            Below lowest precedence
        </member>
        <member name="T:Loyc.Ecs.Parser.EcsTriviaInjector">
            <summary>Trivia injector customized for Enhanced C#.</summary>
            <remarks>
            How newline trivia works in EC# (mostly this is the same as 
            <see cref="T:Loyc.Syntax.StandardTriviaInjector"/>):
            <ul>
            <li>Implicitly, there is a newline before every node within a braced block,
            and <see cref="F:Loyc.Syntax.CodeSymbols.TriviaAppendStatement"/> is required to suppress 
            it. The Loyc tree does not specify whether or not there is a newline before
            the closing brace; it is assumed that there should be a newline unless ALL
            children of the braced block use %appendStatement.</li>
            <li>Implicitly, there is a newline before every top-level statement except 
            the first, and %appendStatement can be used to suppress it.</li>
            <li>By default, the printer doesn't print a newline before an opening brace.
            #trivia_newline can be added to the braced block node to represent one.</li>
            <li>This injector explicitly encodes newlines in all other locations. 
            However, the EC# printer is designed to print all syntax trees reasonably 
            whether they have passed through the trivia injector or not. Therefore, on
            non-braced-block child statements of certain nodes (if statements, while
            loops, for loops, and other statements used without braces), the printer
            will print a newline before a child statement if it (1) does not have 
            #trivia_newline or %appendStatement attributes and (2) does not have 
            an ancestor with the <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> style.</li>
            <li>In an if-else statement, `else` has no representation in the syntax 
            tree and may appear to the injector the same as a blank line. In this 
            situation the first newline is attached to the child of #if at index 1,
            and is deleted so that there is only one newline before the second child.</li>
            <li>Constructors that call another constructor (`: base(...)`) get a 
            newline before the colon by default, which can be suppressed with 
            %appendStatement. Note: These constructors have an unusual syntax 
            tree which the standard trivia injector can't handle properly; see comment 
            in DoneAttaching() for details.</li>
            </ul>
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.Parser.EcsPreprocessor">
            <summary>Handles EC# processor directives.</summary>
            <remarks>This class not only preprocesses C# source code, it saves 
            preprocessor directives and comments so that any code excluded by the 
            preprocessor can be added back in later, if and when the parsed code is 
            printed out. For example, given input like this:
            <code>
               void foo // see below
               #if false
               invalid code!
               #endif
               () { Console.WriteLine("foo()!"); }
            </code>
            EcsPreprocessor removes the #if...#endif region of tokens, creates a 
            single Token of type TokenType.PPFalseBlock to represent that region, and
            saves it, after the "see below" comment token, in a list.
            <para/>
            C# has the following preprocessor directives:
            <code>
            #define Id
            #undef Id
            #if expr
            #elif expr
            #else
            #endif
            #warning {arbitrary text}
            #error {arbitrary text}
            #region {arbitrary text}
            #endregion
            #line 123 "filename"
            #pragma warning ...
            #pragma ... // ignored
            </code>
            </remarks>
        </member>
        <member name="P:Loyc.Ecs.Parser.EcsPreprocessor.SaveComments">
            <summary>Controls whether comments and newlines are saved into <see cref="P:Loyc.Ecs.Parser.EcsPreprocessor.TriviaList"/>.</summary>
        </member>
        <member name="P:Loyc.Ecs.Parser.EcsPreprocessor.TriviaList">
            <summary>A list of saved trivia: comments, newlines, preprocessor directives and ignored regions.</summary>
        </member>
        <member name="T:Loyc.Ecs.Parser.TokenExt">
            <summary>Provides the <c>Type()</c> extension method required by 
            <see cref="T:Loyc.Syntax.Lexing.Token"/> and the ToString(Token) method to express an EC# token
            as a string, for tokens that contain sufficient information to do so.</summary>
        </member>
        <member name="M:Loyc.Ecs.Parser.TokenExt.Type(Loyc.Syntax.Lexing.Token)">
            <summary>Converts <c>t.TypeInt</c> to <see cref="T:Loyc.Ecs.Parser.TokenType"/>.</summary>
        </member>
        <member name="M:Loyc.Ecs.Parser.TokenExt.ToString(Loyc.Syntax.Lexing.Token)">
            <summary>Expresses an EC# token as a string.</summary>
            <remarks>Note that some Tokens do not contain enough information to
            reconstruct a useful token string, e.g. comment tokens do not store the 
            comment but merely contain the location of the comment in the source code.
            For performance reasons, a <see cref="T:Loyc.Syntax.Lexing.Token"/> does not have a reference 
            to its source file, so this method cannot return the original string.
            <para/>
            The results are undefined if the token was not produced by <see cref="T:Loyc.Ecs.Parser.EcsLexer"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.EcsNodePrinterWriter">
            <summary>Helper class of <see cref="T:Loyc.Ecs.EcsNodePrinter"/></summary>
        </member>
        <member name="T:Loyc.Ecs.Tests.EcsPrinterAndParserTests">
            <summary>Tests shared between the printer and the parser. Both tests
            together verify round-tripping from AST -> text -> AST.</summary>
            <remarks>Note that the other kind of round-tripping, text -> AST -> text,
            is not fully verified (and is not designed to be supported, as the
            printer is not designed to preserve spacing and the parser is not
            designed to save spacing information.)
            <para/>
            NOTE: The reason why this is a partial class, rather than a base class
            of the other test files, is that there are two derived classes, one
            for the printer and one for the parser. We couldn't do that if we had
            _separate_ classes for each test file.
            </remarks>
        </member>
        <member name="M:Loyc.Ecs.Tests.EcsPrinterAndParserTests.EcsWordAttributes">
            <summary>Demonstrates where word attributes are allowed and where they are not allowed.</summary>
            <remarks>
            Reasons for disallowing non-keyword attributes (known as "word attributes"):
            <para/>
            - On expressions, consider: "partial X();"
              Ambiguity: is this a method declaration, or a method call X() with an attribute?
            - On expressions, consider: "partial x = 0;"
              Ambiguity: is this a variable declaration, or an assignment "x = 0" with an attribute?
            - On the "if" statement, consider "Foo X if (x) { get; }":
              Ambiguity: is it a conditionally-defined property or a regular "if" statement?
            - On constructors, consider "partial X() {}"
              Ambiguity: is this a constructor or a method that returns type "partial"?
              However: we can allow word attributes on a new-style constructor named "this"
            - On forwarded accessors, consider "foo get ==> X;"
              Ambiguity: is this a property forwarded to X with return type "foo", or is it
              a getter forwarded to X with "foo" as a word attribute?
            <para/>
            Reasons for disallowing "new":
            <para/>
            - On expressions, consider: <c>new Foo();</c> or <c>new Foo[10] = x;</c>
              Ambiguity: does this create a new Foo, or is it just a call to method Foo with "new" as an attribute?
              Ambiguity: does this create a new array, or is it just a call to an indexer on the variable Foo?
            <para/>
            Word attributes should be allowed on "return", to allow "yield return".
            </remarks>
        </member>
        <member name="M:Loyc.Ecs.Tests.EcsPrinterAndParserTests.ConstructorAmbiguities">
            <summary>Tests handling of the constructor ambiguity</summary>
            <remarks>
            Constructors look like ordinary method calls. In fact, EC# parsing
            rules do not allow the parser to look at the argument list to 
            determine whether a method is a constructor, and method bodies are
            not required on methods. Furthermore, the parser does not 
            distinguish between executable and non-executable contexts. So
            it's impossible to tell whether
            <code>
            Foo(x);
            Foo(x, y) { }
            </code>
            is a pair of constructors, or a method call plus a macro call. To 
            resolve this conundrum, the parser keeps track of the name of the 
            current class, for the sole purpose of detecting the constructor. 
            The printer, meanwhile, must detect a method call that may be 
            mistaken for a constructor and reformat it as <c>(Foo(x))</c>. Also, 
            when a constructor definition is printed, it must use prefix 
            notation if the name does not match the enclosing class:
            <code>
            #cons(@``, Foo, #(int x), { ... });
            </code>
            When the constructor is called 'this', this(x) is assumed to be a 
            constructor, but that creates a new problem in EC# because you will 
            be allowed to call a constructor inside a constructor body:
            <code>
            this(int x) { this(x, x); }
            </code>
            This parses successfully because the parser will not allow 
            constructor definitions inside methods. The printer, in turn, will
            track whether it is in a space definition or not. It can print a
            constructor that is directly within a space definition, but in other
            contexts will use prefix notation to ensure that round-tripping 
            succeeds. When the syntax tree contains a method call to 'this' 
            (which is stored as #this internally), it may have to be enclosed 
            in parens or shown as `#this` to avoid ambiguity.
            <para/>
            Finally, a constructor with the wrong name can still be parsed if
            it calls some other constructor with a colon:
            <code>
            class Foo { Fub() : base() { } }
            </code>
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.Tests.EcsParserTests">
            <summary>EC# parser tests. Most of the tests are inherited.</summary>
        </member>
        <member name="T:Loyc.Ecs.Tests.EcsNodePrinterTests">
            <summary>EC# node printer tests. Most of the tests are inherited.</summary>
        </member>
        <member name="T:Loyc.Ecs.EcsPrecedence">
            <summary>Contains <see cref="T:Loyc.Syntax.Precedence"/> objects that represent the 
            precedence rules of EC#.</summary>
            <remarks>
            Summary:
            <br/>100+: Primary: x.y x::y f(x) a[i] etc.
            <br/>90+: Prefix: +  -  !  ~  ++x  --x  (T)x 
            <br/>80+: Power: x**y
            <br/>70+: Mult: * / %
            <br/>60+: Add: + -     (Shift is 56 but ideally would be 70)
            <br/>50+: Range: ..    (`custom operators` are 28 to 55)
            <br/>40+: Compare: &lt; > &lt;= >= is as using == !=
            <br/>30+: Bitwise &amp;^|  (Ideally would be 54..59)
            <br/>20+: Conditional &amp;&amp; || ^^
            <br/>10+: Ternary
            <br/> 1:  Assignment
            <br/>-1:  Lambda (only the right-hand side of '=>')
            <para/>
            When printing an expression, we avoid emitting <c>x | y == z</c> because 
            the ranges of == and | overlap. Instead <see cref="T:Loyc.Ecs.EcsNodePrinter"/> prints 
            <c>@`'|`(x, y == z)</c>. Admittedly this is rather ugly, but you can enable
            the <see cref="P:Loyc.Syntax.ILNodePrinterOptions.AllowChangeParentheses"/> option, which allows 
            parenthesis to be added so that a Loyc tree with the structure 
            <c>@`'|`(x, y == z)</c> is emitted as <c>x | (y == z)</c>, even though the 
            latter is a slightly different tree.
            <para/>
            Most of the operators use a range of two adjacent numbers, e.g. 10..11. 
            This represents a couple of ideas for future use in a compiler that allows
            you to define new operators; one idea is, you could give new operators the
            "same" precedence as existing operators, but make them immiscible with 
            those operators... yet still make them miscible with another new operator.
            For instance, suppose you define two new operators `glob` and `fup` with
            PrecedenceRange 41..41 and 40..40 respectively. Then neither can be mixed
            with + and -, but they can be mixed with each other and `fup` has higher
            precedence. Maybe this is not very useful, but hey, why not? If simply
            incrementing a number opens up new extensibility features, I'm happy to
            do it. (I could have used a non-numeric partial ordering system to do
            the same thing, but it would have been more complex, and of questionable
            value.)
            </remarks>
            <seealso cref="T:Loyc.Syntax.Precedence"/>
        </member>
        <member name="T:Loyc.Ecs.EcsValidators">
            <summary>
            A class filled with methods for checking whether a node has the correct 
            <see cref="P:Loyc.Syntax.LNode.Name"/> and structure. For example, <c>IsPropertyDefinition(node)</c>
            checks whether <c>node</c> meets the requirements for being a property 
            definition, such as having a Name equal to #property, and having name 
            and return value that are complex identifiers.
            </summary>
            <remarks>This class also has useful helper functions, such as <see cref="M:Loyc.Ecs.EcsValidators.KeyNameComponentOf(Loyc.Syntax.LNode)"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.EcsValidators.Pedantics">
            <summary>This is needed by the EC# node printer, but perhaps no one else.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.SpaceDefinitionKind(Loyc.Syntax.LNode,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Returns the space kind, which is one of the names #struct, 
            #class, #enum, #interface, #namespace, #alias, #trait, or null if the 
            node Name or structure is not valid for a space statement.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.SpaceDefinitionKind(Loyc.Syntax.LNode,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Returns the space kind, which is one of the names #struct, 
            #class, #enum, #interface, #namespace, #alias, #trait, or null if the 
            node Name or structure is not valid for a space statement.</summary>
            <param name="n">The node to examine.</param>
            <param name="name">Name of the space.</param>
            <param name="bases">bases.Args will be the list of base types.</param>
            <param name="body">A braced block of statements holding the contents of the space.</param>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.MethodDefinitionKind(Loyc.Syntax.LNode,System.Boolean,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>If the given node has a valid syntax tree for a method definition,
            a constructor, or (when orDelegate is true) a delegate definition, gets
            the definition kind (#fn, #cons, or #delegate).</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsNormalMethod(Loyc.Syntax.LNode,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Alias for <see cref="M:Loyc.Ecs.EcsValidators.MethodDefinitionKind(Loyc.Syntax.LNode,System.Boolean,Loyc.Ecs.EcsValidators.Pedantics)"/> that returns true if 
            MethodDefinitionKind returns #fn.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.MethodDefinitionKind(Loyc.Syntax.LNode,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,System.Boolean,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>If the given node has a valid syntax tree for a method definition,
            a constructor, or (when orDelegate is true) a delegate definition, gets
            the definition kind (#fn, #cons, or #delegate).</summary>
            <param name="retType">Return type of the method (if it's a constructor, this will be the empty identifier).</param>
            <param name="name">Name of the method.</param>
            <param name="args">args.Args is the argument list of the method.</param>
            <param name="body">The method body, or null if there is no method body. 
            The method body calls <see cref="F:Loyc.Syntax.CodeSymbols.Braces"/> if the method is a 
            non-lambda-style method.</param>
            <returns>The definition kind (#fn, #cons, or #delegate), or null if it's no kind of method.</returns>
            <remarks>
            Method declarations (no body) also count.
            <para/>
            A destructor counts as a #fn with a method name that calls the ~ operator.
            </remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsPropertyDefinition(Loyc.Syntax.LNode,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Returns true iff the given node has a valid syntax tree for a property definition.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsPropertyDefinition(Loyc.Syntax.LNode,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Returns true iff the given node has a valid syntax tree for 
            a property definition, and gets the component parts of the definition.</summary>
            <remarks>The body may be anything. If it calls CodeSymbols.Braces, it's a normal 
            body, otherwise it's a getter-only body (e.g. int Foo => 42). Indexer 
            properties can have an argument list, e.g. <c>T Foo[int x] { get; }</c>
            would have a syntax tree like <c>#property(T, Foo, #(#var(#int32, x)), { get; })</c>.</remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsVariableDeclExpr(Loyc.Syntax.LNode,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Verifies that a declaration of a single variable is valid, and gets its parts.</summary>
            <param name="expr">Potential variable or field declaration</param>
            <param name="type">Variable type (empty identifier if `var`)</param>
            <param name="name">Variable name (identifier or $substutution expr)</param>
            <param name="initialValue">Initial value that is assigned in <c>expr</c>, or null if unassigned.</param>
            <returns>True if <c>expr</c> is declaration of a single variable.</returns>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsPrintableTypeParam(Loyc.Syntax.LNode,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Checks if 'n' is a legal type parameter definition.</summary>
            <remarks>A type parameter definition must be a simple symbol with at 
            most one #in or #out attribute, and at most one #where attribute with
            an argument list consisting of complex identifiers.</remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.IsIsTest(Loyc.Syntax.LNode,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Syntax.LNode@,Loyc.Ecs.EcsValidators.Pedantics)">
            <summary>Checks whether an expression is a valid "is" test (pattern-
            matching expression) such as "x is Foo", "x is Foo y" or "x is Foo y(z)".</summary>
            <remarks>The format of a valid "is" test is <c>@'is(subject, type_or_vardecl, extraArgsList)</c>.
            For example <c>a is Foo</c> would be <c>@'is(a, Foo)</c> and
            <c>a is Foo b(c, d)</c> would be <c>@'is(a, #var(Foo, b), #(c, d))</c>.
            Unary "is" expressions like <c>is Foo</c> are stored as binary expressions 
            with an empty identifier as the left-hand side: <c>@'is(@``, Foo)</c>.
            </remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.KeyNameComponentOf(Loyc.Syntax.LNode)">
            <summary>Given a complex name such as <c>global::Foo&lt;int>.Bar&lt;T></c>,
            this method identifies the base name component, which in this example 
            is Bar. This is used, for example, to identify the expected name for
            a constructor based on the class name, e.g. <c>Foo&lt;T></c> => Foo.</summary>
            <remarks>It is not verified that name is a complex identifier. There
            is no error detection but in some cases an empty name may be returned, 
            e.g. for input like <c>Foo."Hello"</c>.</remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsValidators.SanitizeIdentifier(System.String)">
            <summary>Eliminates punctuation and special characters from a string so
            that the string can be used as a plain C# identifier, e.g. 
            "I'd" => "I_aposd", "123" => "_123", "+5" => "_plus5".</summary>
            <remarks>The empty string "" becomes "__empty__", ASCII punctuation becomes 
            "_xyz" where xyz is an HTML entity name, e.g. '!' becomes "_excl",
            and all other characters become "Xxx" where xx is the hexadecimal 
            representation of the code point. Designed for the Unicode BMP only.</remarks>
        </member>
        <member name="T:Loyc.Ecs.EcsLanguageService">
            <summary>The <see cref="F:Loyc.Ecs.EcsLanguageService.Value"/> property provides easy access to the lexer, 
            parser and printer for Enhanced C#.</summary>
            <remarks>
            EC# overview: https://ecsharp.net
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.EcsNodePrinter">
            <summary>Encapsulates the code for printing an <see cref="T:Loyc.Syntax.LNode"/> 
            to EC# source code.</summary>
            <remarks>
            To print EC# code, you not use this class directly. Instead, call 
            <see cref="M:Loyc.Ecs.EcsLanguageService.Print(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)"/> via 
            <see cref="F:Loyc.Ecs.EcsLanguageService.WithPlainCSharpPrinter"/> or via
            <see cref="F:Loyc.Ecs.EcsLanguageService.Value"/>. This class does have some static
            methods like <see cref="M:Loyc.Ecs.EcsNodePrinter.PrintLiteral(System.Object,Loyc.Syntax.NodeStyle)"/> and 
            <see cref="M:Loyc.Ecs.EcsNodePrinter.PrintId(Loyc.Symbol,Loyc.Ecs.EcsNodePrinter.IdPrintMode)"/> that are useful for printing tokens efficiently.
            <para/>
            This class is designed to faithfully preserve most Loyc trees; almost any 
            Loyc tree that can be represented as EC# source code will be represented 
            properly by this class, so that it is possible to parse the output text 
            back into a Loyc tree equivalent to the one that was printed. Originally 
            this class was meant to provide round-tripping from Loyc trees to text and 
            back, but Enhanced C# is syntactically very complicated and as a result 
            this printer may contain bugs or (for the sake of practicality) minor 
            intentional limitations that cause round-tripping not to work in rare 
            cases. If you need perfect round-tripping, use LES instead 
            (<see cref="T:Loyc.Syntax.Les.LesLanguageService"/>).
            <para/>
            Only the attributes, head (<see cref="P:Loyc.Syntax.LiteralNode.Value"/>, 
            <see cref="P:Loyc.Syntax.IdNode.Name"/> or <see cref="P:Loyc.Syntax.CallNode.Target"/>), and arguments 
            of nodes are round-trippable. Superficial properties such as original 
            source code locations and the <see cref="P:Loyc.Syntax.LNode.Style"/> are, in 
            general, lost, although the printer can faithfully reproduce some (not 
            all) <see cref="T:Loyc.Syntax.NodeStyle"/>s (this caveat applies equally to LES). Also, 
            any attribute whose Name starts with the trivia marker % may be dropped, 
            because these attributes are considered extensions of the NodeStyle. 
            However, the style indicated by the % attribute will be used if the printer 
            recognizes it.
            <para/>
            For round-tripping to work, there are a couple of restrictions on the 
            input tree:
            <ol>
            <li>Only literals that can exist in C# source code are allowed. For 
                example, Values of type int, string, and double are acceptable, but
                Values of type Regex or int[] are not, because single tokens cannot
                represent these types in C# source code. The printer ignores Values of 
                non-literal nodes, and non-representable literals are printed out
                using ToString().</li>
            <li>Names must come from the global symbol pool (<see cref="F:Loyc.GSymbol.Pool"/>).
                The printer will happily print Symbols from other pools, but there is
                no way to indicate the pool in source code, so the parser always 
                recreates symbols in the global pool. Non-global symbols are used
                after semantic analysis, so there is no way to faithfully represent
                the results of semantic analysis.</li>
            </ol>
            </remarks>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.StartStmt">
            <summary>Context: beginning of statement (Named argument operator not supported, allow multiple #var decl)</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.StartExpr">
            <summary>Context: beginning of expression (#var must have initial value)</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.ContinueExpr">
            <summary>Context: middle of expression, top level (#var and named arguments not supported)</summary>
        </member>
        <member name="T:Loyc.Ecs.EcsNodePrinter.SPResult">
            <summary>Result from statement printer</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.KeyNameComponentOf(Loyc.Syntax.LNode)">
            <summary>Given a complex name such as <c>global::Foo&lt;int>.Bar&lt;T></c>,
            this method identifies the base name component, which in this example 
            is Bar. This is used, for example, to identify the expected name for
            a constructor based on the class name, e.g. <c>Foo&lt;T></c> => Foo.</summary>
            <remarks>This was moved to EcsValidators.</remarks>
        </member>
        <member name="P:Loyc.Ecs.EcsNodePrinter.ErrorSink">
            <summary>Any error that occurs during printing is printed to this object.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.PrintPlainCSharp(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Prints a node while avoiding syntax specific to Enhanced C#.</summary>
            <remarks>This does not perform a conversion from EC# to C#. If the 
            syntax tree contains code that has no direct C# representation, the EC# 
            representation will be printed.</remarks>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.PrintECSharp(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode,Loyc.Syntax.ILNodePrinterOptions)">
            <summary>Prints a node as EC# code.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.Print(Loyc.Syntax.LNode,System.Text.StringBuilder,Loyc.IMessageSink,Loyc.Syntax.ParsingMode)">
            <summary>Attaches a new <see cref="T:System.Text.StringBuilder"/>, then prints a node 
            with <see cref="M:Loyc.Ecs.EcsNodePrinter.Print(Loyc.Syntax.LNode,Loyc.Syntax.ParsingMode)"/>.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.Print(Loyc.Syntax.LNode,System.IO.TextWriter,Loyc.IMessageSink,Loyc.Syntax.ParsingMode)">
            <summary>Attaches a new <see cref="T:System.IO.TextWriter"/>, then prints a node 
            with <see cref="M:Loyc.Ecs.EcsNodePrinter.Print(Loyc.Syntax.LNode,Loyc.Syntax.ParsingMode)"/>.</summary>
        </member>
        <member name="M:Loyc.Ecs.EcsNodePrinter.Print(Loyc.Syntax.LNode,Loyc.Syntax.ParsingMode)">
            <summary>Print a node to the writer attached to this printer.</summary>
            <param name="mode">A value of <see cref="T:Loyc.Syntax.ParsingMode"/> or <see cref="T:Loyc.Syntax.NodeStyle"/>.
            Only three modes are recognized: <see cref="F:Loyc.Syntax.NodeStyle.Expression"/>,
            <see cref="F:Loyc.Syntax.NodeStyle.Expression"/>, and <see cref="F:Loyc.Syntax.NodeStyle.Default"/> 
            which prints the node as a statement and is the default (i.e. null and
            most other values have the same effect)</param>
        </member>
        <member name="T:Loyc.Ecs.EcsNodePrinter.Ambiguity">
            <summary>Internal enum (marked public for an obscure technical reason). 
            These are flags that represent special situations in EC# syntax.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.AllowUnassignedVarDecl">
            <summary>The expression can contain uninitialized variable 
            declarations, e.g. because it is the subject of an assignment.
            In the tree "(x + y, int z) = (a, b)", this flag is passed down to 
            "(x + y, int z)" and then down to "int y" and "x + y", but it 
            doesn't propagate down to "x", "y" and "int".</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.CastRhs">
            <summary>The expression is the right side of a traditional cast, so 
            the printer must avoid ambiguity in case of the following prefix 
            operators: <c>(Foo)&amp;x, (Foo)*x, (Foo)++(x), (Foo)--(x)</c> 
            (the (Foo)++(x) case is parsed as a post-increment and a call).</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.IsCallTarget">
            <summary>The expression is in a location where, if it is parenthesized
            and has the syntax of a data type inside, it will be treated as a cast.
            This occurs when a call that is printed with prefix notation has a 
            parenthesized target node, e.g. (target)(arg). The target node can avoid 
            the syntax of a data type by adding "[ ]" (an empty set of 
            attributes) at the beginning of the expression.</summary>
            <remarks>This is also used in the case of @`~`((Foo), x) which must not 
            be printed as `(Foo) ~ x`</remarks>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.NoBracedBlock">
            <summary>No braced block permitted directly here (inside "if" clause)</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.FinalStmt">
            <summary>The current statement is the last one in the enclosing 
            block, so #result can be represented by omitting a semicolon.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.TypeContext">
            <summary>The "expression" being printed is a type, or part of a type,
            which may have special printing rules (e.g. consider <c>Foo?[]</c>, 
            <c>List&lt;(X,Y)></c>.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.InDefinitionName">
            <summary>The expression being printed is a complex identifier that
            may contain special attributes, e.g. <c>Foo&lt;out T></c>.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.InOf">
            <summary>Printing a type inside angle brackets or !(...).</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.AllowPointer">
            <summary>Allow pointer notation (when combined with TypeContext). 
            Also, a pointer is always allowed at the beginning of a statement,
            which is detected by the precedence context (StartStmt).</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.UseBacktick">
            <summary>Used to communicate to the operator printers that a binary 
            call should be expressed with the backtick operator.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.ForEachInitializer">
            <summary>Forces a variable declaration to be allowed as the 
            initializer of a foreach loop.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.ElseClause">
            <summary>After 'else', valid 'if' statements are not indented.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.NoParentheses">
            <summary>A statement is being printed, or the return value or name
            of a method, so parentheses cannot be emitted here.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.AllowThisAsCallTarget">
            <summary>Print #this(...) as this(...) inside a method</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.NoIfWithoutElse">
            <summary>This location is the 'true' side of an if-else statement.
            At this location, no 'if' without 'else' is allowed because the
            outer else would, upon parsing, be associated with the inner 'if'.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.ForceAttributeList">
            <summary>Force PrintAttrs to print an empty attribute list `[]` which 
            has the effect of allowing unassigned variable declarations anywhere.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.NewlineBeforeChildStmt">
            <summary>A signal that IF there is no trivia indicating whether or not 
            to print a newline before the current statement, one should be printed.</summary>
        </member>
        <member name="F:Loyc.Ecs.EcsNodePrinter.Ambiguity.OneLiner">
            <summary>Indicates that this node, or one of its parents, has the style
            <see cref="F:Loyc.Syntax.NodeStyle.OneLiner"/> which suppresses newlines.</summary>
        </member>
        <member name="T:Loyc.Ecs.ICI">
            <summary>Flags for <see cref="M:Loyc.Ecs.EcsNodePrinter.IsComplexIdentifier(Loyc.Syntax.LNode,Loyc.Ecs.ICI)"/>.</summary>
        </member>
        <member name="T:Loyc.Ecs.SpaceOpt">
            <summary>Controls the locations where spaces appear as <see cref="T:Loyc.Ecs.EcsNodePrinter"/> 
            is printing.</summary>
            <remarks>
            Note: Spaces around prefix and infix operators are controlled by 
            <see cref="P:Loyc.Ecs.EcsPrinterOptions.SpaceAroundInfixStopPrecedence"/> and
            <see cref="P:Loyc.Ecs.EcsPrinterOptions.SpaceAfterPrefixStopPrecedence"/>.
            </remarks>
        </member>
        <member name="T:Loyc.Ecs.NewlineOpt">
            <summary>Flags to control situations in which newlines should be added automatically by the EC# printer.</summary>
        </member>
        <member name="F:Loyc.Ecs.NewlineOpt.Default">
            <summary>Default value of EcsNodePrinter.NewlineOptions</summary>
            <remarks>Oct 2016: Some defaults have been turned off because newlines can 
            now be added with %newline, and turning on some NewlineOpts currently
            causes double newlines (i.e. a blank line) when the LNode uses %newline
            at the same time.</remarks>
        </member>
        <member name="T:Loyc.Ecs.EcsPrinterOptions">
            <summary>Options to control the way <see cref="T:Loyc.Ecs.EcsNodePrinter"/>'s output is formatted.</summary>
            <remarks>
            <see cref="T:Loyc.Ecs.EcsPrinterOptions"/> has some configuration options that will 
            defeat round-tripping (from <see cref="T:Loyc.Syntax.LNode"/> to text and back) but will 
            make the output look better. For example, 
            <see cref="P:Loyc.Ecs.EcsPrinterOptions.AllowExtraBraceForIfElseAmbig"/> will print a tree such as 
            <c>#if(a, #if(b, f()), g())</c> as <c>if (a) { if (b) f(); } else g();</c>,
            by adding braces to eliminate prefix notation, even though braces make the 
            Loyc tree different.
            </remarks>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.MixImmiscibleOperators">
            <summary>Allows operators to be mixed that will cause the parser to 
            produce a warning. An example is <c>x &amp; @==(y, z)</c>: if you enable 
            this option, it will be printed as <c>x &amp; y == z</c>, which the parser
            will complain about because mixing those operators is deprecated.
            </summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.AllowExtraBraceForIfElseAmbig">
            <summary>Solve if-else ambiguity by adding braces rather than reverting 
            to prefix notation.</summary>
            <remarks>
            For example, the tree <c>#if(c1, #if(c2, x++), y++)</c> will be parsed 
            incorrectly if it is printed <c>if (c1) if (c2) x++; else y++;</c>. This
            problem can be resolved either by adding braces around <c>if (c2) x++;</c>,
            or by printing <c>#if(c2, x++)</c> in prefix notation.
            </remarks>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.DropNonDeclarationAttributes">
            <summary>Suppresses printing of attributes inside methods and inside
            subexpressions, except on declaration or definition statements where
            attributes are normally allowed (such as classes, methods and generic
            type parameters). This option also avoids prefix notation when the 
            attributes would have required it, e.g. <c>@+([Foo] a, b)</c> can be 
            printed "a + b" instead.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.OmitMissingArguments">
            <summary>When an argument to a method or macro has an empty name (@``),
            it will be omitted completely if this flag is set.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.OmitSpaceTrivia">
            <summary>When this flag is set, space trivia attributes are ignored
            (e.g. <see cref="F:Loyc.Syntax.CodeSymbols.TriviaSpaceAfter"/>).</summary>
            <remarks>Note: since EcsNodePrinter inserts its own spaces 
            automatically, space trivia (if any) may be redundant unless you set 
            <see cref="P:Loyc.Ecs.EcsPrinterOptions.SpaceOptions"/> and/or <see cref="P:Loyc.Ecs.EcsPrinterOptions.NewlineOptions"/> to zero.</remarks>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.ObeyRawText">
            <summary>When this flag is set, raw text trivia attributes (e.g. <see 
            cref="F:Loyc.Syntax.CodeSymbols.TriviaRawTextBefore"/>) are obeyed (cause raw text 
            output); otherwise such attributes are treated as unknown trivia and, 
            if <see cref="P:Loyc.Syntax.LNodePrinterOptions.OmitUnknownTrivia"/> is false, 
            printed as attributes.</summary>
            <remarks>Initial value: true</remarks>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.QuoteUnprintableLiterals">
            <summary>When the printer encounters an unprintable literal, it calls
            Value.ToString(). When this flag is set, the string is placed in double
            quotes; when this flag is clear, it is printed as raw text.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.AllowConstructorAmbiguity">
            <summary>Causes the ambiguity between constructors and method calls to
            be ignored; see <see cref="M:Loyc.Ecs.Tests.EcsPrinterAndParserTests.ConstructorAmbiguities"/>.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.AvoidMacroSyntax">
            <summary>Prints statements like "foo (...) bar()" in the equivalent form
            "foo (..., bar())" instead. Does not affect foo {...} because property
            and event definitions require this syntax (get {...}, set {...}).</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.PreferPlainCSharp">
            <summary>Prefers plain C# syntax for certain other things (not covered
            by the other options), even when the syntax tree requests a different 
            style, e.g. EC# cast operators are blocked so x(->int) becomes (int) x,
            and @`at-identifiers` are sanitized.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.SpaceOptions">
            <summary>Controls the locations where spaces should be emitted.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.NewlineOptions">
            <summary>Controls the locations where newlines should be emitted.</summary>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.SpaceAroundInfixStopPrecedence">
            <summary>The printer avoids printing spaces around infix (binary) 
            operators that have the specified precedence or higher.</summary>
            <seealso cref="T:Loyc.Ecs.EcsPrecedence"/>
        </member>
        <member name="P:Loyc.Ecs.EcsPrinterOptions.SpaceAfterPrefixStopPrecedence">
            <summary>The printer avoids printing spaces after prefix operators 
            that have the specified precedence or higher.</summary>
        </member>
    </members>
</doc>
